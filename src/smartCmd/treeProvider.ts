// SmartCmd Types and Classes
import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as aiServices from './aiServices';

// Input field interface for commands that need user input
export interface InputField {
	placeholder: string;  // Placeholder text for the input (e.g., "Enter commit message")
	variable: string;     // Variable name to replace in command (e.g., "{message}")
}

// Button interface
export interface smartCmdButton {
	name: string;
	cmd: string;
	user_description?: string;      // Description provided by the user
	ai_description?: string;        // Description generated by AI
	inputs?: InputField[];          // Optional input fields for dynamic commands
	scope?: 'workspace' | 'global';
}

// Section type for organizing buttons
type SectionType = 'smartcmd' | 'global' | 'workspace';

// Tree item base class
class SmartCmdTreeItemBase extends vscode.TreeItem {
	constructor(
		label: string,
		collapsibleState: vscode.TreeItemCollapsibleState,
		public readonly itemType: 'smartcmd' | 'section' | 'button'
	) {
		super(label, collapsibleState);
	}
}

// SmartCmd parent tree item
class SmartCmdParentTreeItem extends SmartCmdTreeItemBase {
	constructor(
		public readonly totalButtons: number
	) {
		super(
			'SmartCmd',
			vscode.TreeItemCollapsibleState.Expanded,
			'smartcmd'
		);
		this.description = `${totalButtons} button${totalButtons !== 1 ? 's' : ''}`;
		this.contextValue = 'smartcmd';
	}
}

// Section tree item (parent nodes for Global/Workspace)
class SmartCmdSectionTreeItem extends SmartCmdTreeItemBase {
	constructor(
		public readonly section: SectionType,
		public readonly buttonCount: number
	) {
		super(
			section === 'global' ? 'Global Commands' : 'Workspace Commands',
			vscode.TreeItemCollapsibleState.Expanded,
			'section'
		);
		this.description = `${buttonCount} button${buttonCount !== 1 ? 's' : ''}`;
		this.contextValue = 'section';
		this.iconPath = new vscode.ThemeIcon(section === 'global' ? 'globe' : 'window');
	}
}

// Tree item for buttons
class SmartCmdButtonTreeItem extends SmartCmdTreeItemBase {
	constructor(
		public readonly button: smartCmdButton,
		public readonly collapsibleState: vscode.TreeItemCollapsibleState
	) {
		super(button.name, collapsibleState, 'button');
		
		// Build tooltip with both descriptions
		const tooltipParts: string[] = [];
		
		// Add user description if available
		if (!button.ai_description) {
			tooltipParts.push(`User: ${button.user_description}`);
		}
		
		// Add AI description if available
		if (button.ai_description) {
			tooltipParts.push(`AI: ${button.ai_description}`);
		}
		
		// Fallback to command if no descriptions
		if (tooltipParts.length === 0) {
			tooltipParts.push(`Command: ${button.cmd}`);
		}
		
		// Add input fields info
		const inputInfo = button.inputs && button.inputs.length > 0 
			? `\nInputs: ${button.inputs.map(i => i.placeholder).join(', ')}` 
			: '';
		
		this.tooltip = tooltipParts.join('\n') + inputInfo;
		
		// Display AI description or user description in the tree view description field
		this.description = button.ai_description || button.user_description || '';
		
		this.iconPath = new vscode.ThemeIcon('play');
		
		// Set contextValue based on button scope for conditional menu items
		this.contextValue = button.scope === 'global' ? 'globalButton' : 'workspaceButton';
		
		// Make it clickable - pass the entire button object for input handling
		this.command = {
			command: 'devboost.executeButton',
			title: 'Execute Button',
			arguments: [button]
		};
	}
}

// Tree data provider for buttons with hierarchical structure
export class SmartCmdButtonsTreeProvider implements vscode.TreeDataProvider<SmartCmdTreeItemBase> {
	private _onDidChangeTreeData: vscode.EventEmitter<SmartCmdTreeItemBase | undefined | null | void> = new vscode.EventEmitter<SmartCmdTreeItemBase | undefined | null | void>();
	readonly onDidChangeTreeData: vscode.Event<SmartCmdTreeItemBase | undefined | null | void> = this._onDidChangeTreeData.event;

	private buttons: smartCmdButton[] = [];

	constructor(
		private context: vscode.ExtensionContext,
		private globalButtonsPath: string
	) {}

	refresh(): void {
		this._onDidChangeTreeData.fire();
	}

	async loadButtons(): Promise<void> {
		this.buttons = [];

		// Load global buttons from JSON file
		if (this.globalButtonsPath) {
			try {
				const content = await fs.readFile(this.globalButtonsPath, 'utf-8');
				const globalButtons = JSON.parse(content);
				this.buttons.push(...globalButtons.map((b: smartCmdButton) => ({ ...b, scope: 'global' as const })));
			} catch {
				// File doesn't exist or is invalid, no global buttons to load
			}
		}

		// Load workspace buttons
		if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
			const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
			const buttonsFilePath = path.join(workspaceRoot, '.vscode', 'devboost.json');

			try {
				const content = await fs.readFile(buttonsFilePath, 'utf-8');
				const workspaceButtons = JSON.parse(content);
				this.buttons.push(...workspaceButtons.map((b: smartCmdButton) => ({ ...b, scope: 'workspace' as const })));
			} catch {
				// File doesn't exist, no workspace buttons to load
			}
		}

		this.refresh();
	}

	getTreeItem(element: SmartCmdTreeItemBase): vscode.TreeItem {
		return element;
	}

	getChildren(element?: SmartCmdTreeItemBase): Thenable<SmartCmdTreeItemBase[]> {
		// Root level: show SmartCmd parent
		if (!element) {
			const totalButtons = this.buttons.length;
			return Promise.resolve([new SmartCmdParentTreeItem(totalButtons)]);
		}

		// If element is SmartCmd, return sections (Global and Workspace)
		if (element instanceof SmartCmdParentTreeItem) {
			const globalButtons = this.buttons.filter(b => b.scope === 'global');
			const workspaceButtons = this.buttons.filter(b => b.scope === 'workspace');

			const sections: SmartCmdTreeItemBase[] = [];
			
			// Add Global section if there are global buttons
			if (globalButtons.length > 0) {
				sections.push(new SmartCmdSectionTreeItem('global', globalButtons.length));
			}
			
			// Add Workspace section if there are workspace buttons
			if (workspaceButtons.length > 0) {
				sections.push(new SmartCmdSectionTreeItem('workspace', workspaceButtons.length));
			}

			return Promise.resolve(sections);
		}

		// If element is a section, return its buttons
		if (element instanceof SmartCmdSectionTreeItem) {
			const sectionButtons = this.buttons
				.filter(b => b.scope === element.section)
				.map(button => new SmartCmdButtonTreeItem(button, vscode.TreeItemCollapsibleState.None));
			
			return Promise.resolve(sectionButtons);
		}

		// If element is a button, it has no children
		return Promise.resolve([]);
	}

	async addButtons(buttons: smartCmdButton[], scope: 'workspace' | 'global'): Promise<number> {
		if (!buttons || buttons.length === 0) {
			vscode.window.showWarningMessage('DevBoost: No buttons to add.');
			return 0;
		}

		// Validate buttons and check for duplicates
		const validButtons: smartCmdButton[] = [];
		const duplicateButtons: Array<{newButton: smartCmdButton, existingButton: smartCmdButton}> = [];
		const invalidButtons: number[] = [];

		// Use withProgress for duplicate checking since it calls AI
		await vscode.window.withProgress({
			location: vscode.ProgressLocation.Notification,
			title: "Checking for duplicate buttons",
			cancellable: false
		}, async (progress) => {
			for (let i = 0; i < buttons.length; i++) {
				const b = buttons[i];
				
				// Check if button is valid
				if (!b.name || !b.cmd || b.name.trim().length === 0 || b.cmd.trim().length === 0) {
					console.warn('DevBoost: Skipping invalid button:', b);
					invalidButtons.push(i);
					continue;
				}

				// Check for duplicates using AI-powered semantic comparison
				progress.report({ message: `${i + 1}/${buttons.length}` });
				const duplicateButton = await aiServices.checkDuplicateButton(b, this.buttons, scope);

				if (duplicateButton) {
					duplicateButtons.push({newButton: b, existingButton: duplicateButton});
					console.warn('DevBoost: Duplicate/similar button:', b.name, '(similar to:', duplicateButton.name + ')');
				} else {
					validButtons.push(b);
				}
			}
		});

		// Show feedback about duplicates - ask for confirmation one by one
		if (duplicateButtons.length > 0) {
			for (const dup of duplicateButtons) {
				const confirmationMessage = `This button appears similar to an existing one:

New Button:
• Name: ${dup.newButton.name}
• Command: ${dup.newButton.cmd}
• Description: ${dup.newButton.ai_description || dup.newButton.user_description || 'N/A'}
• Scope: ${scope === 'global' ? 'Global' : 'Workspace'}

Existing Similar Button:
• Name: ${dup.existingButton.name}
• Command: ${dup.existingButton.cmd}
• Description: ${dup.existingButton.ai_description || dup.existingButton.user_description || 'N/A'}
• Scope: ${dup.existingButton.scope === 'global' ? 'Global' : 'Workspace'}

What would you like to do?`;

				const result = await vscode.window.showWarningMessage(
					confirmationMessage,
					{ modal: true },
					'Add Anyway',
					'Replace Existing',
					'Skip'
				);
				
				if (result === 'Add Anyway') {
					// Add the new button alongside the existing one
					validButtons.push(dup.newButton);
				} else if (result === 'Replace Existing') {
					// Remove the existing button and add the new one
					const existingIndex = this.buttons.findIndex(
						b => b.name === dup.existingButton.name && 
						     b.cmd === dup.existingButton.cmd && 
						     b.scope === dup.existingButton.scope
					);
					if (existingIndex !== -1) {
						this.buttons.splice(existingIndex, 1);
					}
					validButtons.push(dup.newButton);
				}
				// If 'Skip' or closed dialog, do nothing (button not added to validButtons)
			}
		}

		if (validButtons.length === 0) {
			if (invalidButtons.length > 0) {
				vscode.window.showWarningMessage('DevBoost: No valid buttons to add.');
			} else if (duplicateButtons.length > 0) {
				vscode.window.showInformationMessage('DevBoost: All duplicate buttons were skipped.');
			}
			return 0;
		}

		// Add valid, non-duplicate buttons
		const newButtons = validButtons.map(b => ({ ...b, scope }));
		this.buttons.push(...newButtons);
		await this.saveButtons();
		this.refresh();
		
		// Show summary message
		const messages: string[] = [];
		if (validButtons.length > 0) {
			messages.push(`Added ${validButtons.length} button${validButtons.length > 1 ? 's' : ''}`);
		}
		const skippedDuplicates = duplicateButtons.length - duplicateButtons.filter(d => validButtons.includes(d.newButton)).length;
		if (skippedDuplicates > 0) {
			messages.push(`${skippedDuplicates} duplicate${skippedDuplicates > 1 ? 's' : ''} skipped`);
		}
		if (invalidButtons.length > 0) {
			messages.push(`${invalidButtons.length} invalid button${invalidButtons.length > 1 ? 's' : ''} skipped`);
		}
		
		vscode.window.showInformationMessage(`DevBoost: ${messages.join(', ')}.`);
		return validButtons.length;
	}

	async deleteButton(item: SmartCmdButtonTreeItem): Promise<void> {
		console.warn('Delete button invoked for:', item.button);
		if (!item || !item.button) {
			vscode.window.showWarningMessage('DevBoost: Invalid button item.');
			return;
		}

		const index = this.buttons.findIndex(b => b.name === item.button.name && b.cmd === item.button.cmd && b.scope === item.button.scope);
		if (index === -1) {
			vscode.window.showWarningMessage(`DevBoost: Button "${item.button.name}" not found.`);
			return;
		}

		const button = this.buttons[index];
		this.buttons.splice(index, 1);
		
		// Remove from storage
		try {
			if (button.scope === 'global') {
				await this.saveGlobalButtons();
			} else {
				await this.saveWorkspaceButtons();
			}
			
			this.refresh();
			vscode.window.showInformationMessage(`Deleted button: ${button.name}`);
		} catch (error) {
			vscode.window.showErrorMessage(`Failed to delete button: ${button.name}`);
			console.error('Delete button error:', error);
		}
	}

	async editButton(item: SmartCmdButtonTreeItem): Promise<void> {
		if (!item || !item.button) {
			vscode.window.showWarningMessage('DevBoost: Invalid button item.');
			return;
		}

		const index = this.buttons.findIndex(b => b.name === item.button.name && b.cmd === item.button.cmd);
		if (index === -1) {
			vscode.window.showWarningMessage(`DevBoost: Button "${item.button.name}" not found.`);
			return;
		}

		const button = this.buttons[index];

		// Get new name
		const newName = await vscode.window.showInputBox({
			prompt: 'Edit button name',
			value: button.name,
			validateInput: (value) => {
				if (!value || value.trim().length === 0) {
					return 'Button name cannot be empty';
				}
				return null;
			}
		});

		if (!newName) {
			vscode.window.showInformationMessage('Edit cancelled.');
			return;
		}

		// Get new description
		const currentDesc = button.user_description || '';
		const newUserDescription = await vscode.window.showInputBox({
			prompt: 'Edit user description (optional)',
			value: currentDesc,
			placeHolder: 'Brief description of what this button does'
		});

		// Update button - keep user_description, preserve ai_description
		this.buttons[index] = {
			...button,
			name: newName.trim(),
			user_description: newUserDescription?.trim() || button.user_description
		};

		// Save to storage
		try {
			if (button.scope === 'global') {
				await this.saveGlobalButtons();
			} else {
				await this.saveWorkspaceButtons();
			}
			
			this.refresh();
			vscode.window.showInformationMessage(`Updated button: ${newName}`);
		} catch (error) {
			vscode.window.showErrorMessage(`Failed to update button: ${button.name}`);
			console.error('Edit button error:', error);
		}
	}

	private async saveButtons(): Promise<void> {
		await this.saveGlobalButtons();
		await this.saveWorkspaceButtons();
	}

	private async saveGlobalButtons(): Promise<void> {
		if (!this.globalButtonsPath) {
			return;
		}

		try {
			// Ensure the directory exists
			await fs.mkdir(path.dirname(this.globalButtonsPath), { recursive: true });
			
			const globalButtons = this.buttons
				.filter(b => b.scope === 'global')
				.map(({ scope, ...b }) => b);
			
			await fs.writeFile(this.globalButtonsPath, JSON.stringify(globalButtons, null, 2));
		} catch (error) {
			console.error('Error saving global buttons:', error);
		}
	}

	private async saveWorkspaceButtons(): Promise<void> {
		if (!vscode.workspace.workspaceFolders || vscode.workspace.workspaceFolders.length === 0) {
			return;
		}

		const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
		const buttonsFilePath = path.join(workspaceRoot, '.vscode', 'devboost.json');

		try {
			await fs.mkdir(path.dirname(buttonsFilePath), { recursive: true });
			const workspaceButtons = this.buttons
				.filter(b => b.scope === 'workspace')
				.map(({ scope, ...b }) => b);
			await fs.writeFile(buttonsFilePath, JSON.stringify(workspaceButtons, null, 2));
		} catch (error) {
			console.error('Error saving workspace buttons:', error);
		}
	}
}


