// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as aiServices from './aiServices';

// Input field interface for commands that need user input
interface InputField {
	placeholder: string;  // Placeholder text for the input (e.g., "Enter commit message")
	variable: string;     // Variable name to replace in command (e.g., "{message}")
}

// Button interface
interface Button {
	name: string;
	cmd: string;
	user_description?: string;      // Description provided by the user
	ai_description?: string;        // Description generated by AI
	inputs?: InputField[];          // Optional input fields for dynamic commands
	scope?: 'workspace' | 'global';
}

// Global variables
let activityLogPath: string | undefined;
let buttonsProvider: ButtonsTreeProvider;
let globalButtonsPath: string | undefined;
let promptInputPath: string | undefined;

// Track commands executed by SmartCmd per workspace to exclude from activity log
// Key: workspace folder path, Value: Set of executed commands
const smartCmdExecutedCommands = new Map<string, Set<string>>();

// Section type for organizing buttons
type SectionType = 'smartcmd' | 'global' | 'workspace';

// Tree item base class
class TreeItemBase extends vscode.TreeItem {
	constructor(
		label: string,
		collapsibleState: vscode.TreeItemCollapsibleState,
		public readonly itemType: 'smartcmd' | 'section' | 'button'
	) {
		super(label, collapsibleState);
	}
}

// SmartCmd parent tree item
class SmartCmdTreeItem extends TreeItemBase {
	constructor(
		public readonly totalButtons: number
	) {
		super(
			'SmartCmd',
			vscode.TreeItemCollapsibleState.Expanded,
			'smartcmd'
		);
		this.description = `${totalButtons} button${totalButtons !== 1 ? 's' : ''}`;
		this.contextValue = 'smartcmd';
	}
}

// Section tree item (parent nodes for Global/Workspace)
class SectionTreeItem extends TreeItemBase {
	constructor(
		public readonly section: SectionType,
		public readonly buttonCount: number
	) {
		super(
			section === 'global' ? 'Global Commands' : 'Workspace Commands',
			vscode.TreeItemCollapsibleState.Expanded,
			'section'
		);
		this.description = `${buttonCount} button${buttonCount !== 1 ? 's' : ''}`;
		this.contextValue = 'section';
		this.iconPath = new vscode.ThemeIcon(section === 'global' ? 'globe' : 'window');
	}
}

// Tree item for buttons
class ButtonTreeItem extends TreeItemBase {
	constructor(
		public readonly button: Button,
		public readonly collapsibleState: vscode.TreeItemCollapsibleState
	) {
		super(button.name, collapsibleState, 'button');
		
		// Build tooltip with both descriptions
		const tooltipParts: string[] = [];
		
		// Add user description if available
		if (!button.ai_description) {
			tooltipParts.push(`User: ${button.user_description}`);
		}
		
		// Add AI description if available
		if (button.ai_description) {
			tooltipParts.push(`AI: ${button.ai_description}`);
		}
		
		// Fallback to command if no descriptions
		if (tooltipParts.length === 0) {
			tooltipParts.push(`Command: ${button.cmd}`);
		}
		
		// Add input fields info
		const inputInfo = button.inputs && button.inputs.length > 0 
			? `\nInputs: ${button.inputs.map(i => i.placeholder).join(', ')}` 
			: '';
		
		this.tooltip = tooltipParts.join('\n') + inputInfo;
		
		// Display AI description or user description in the tree view description field
		this.description = button.ai_description || button.user_description || '';
		
		this.iconPath = new vscode.ThemeIcon('play');
		
		// Set contextValue based on button scope for conditional menu items
		this.contextValue = button.scope === 'global' ? 'globalButton' : 'workspaceButton';
		
		// Make it clickable - pass the entire button object for input handling
		this.command = {
			command: 'devboost.executeButton',
			title: 'Execute Button',
			arguments: [button]
		};
	}
}

// Tree data provider for buttons with hierarchical structure
class ButtonsTreeProvider implements vscode.TreeDataProvider<TreeItemBase> {
	private _onDidChangeTreeData: vscode.EventEmitter<TreeItemBase | undefined | null | void> = new vscode.EventEmitter<TreeItemBase | undefined | null | void>();
	readonly onDidChangeTreeData: vscode.Event<TreeItemBase | undefined | null | void> = this._onDidChangeTreeData.event;

	private buttons: Button[] = [];

	constructor(private context: vscode.ExtensionContext) {}

	refresh(): void {
		this._onDidChangeTreeData.fire();
	}

	async loadButtons(): Promise<void> {
		this.buttons = [];

		// Load global buttons from JSON file
		if (globalButtonsPath) {
			try {
				const content = await fs.readFile(globalButtonsPath, 'utf-8');
				const globalButtons = JSON.parse(content);
				this.buttons.push(...globalButtons.map((b: Button) => ({ ...b, scope: 'global' as const })));
			} catch {
				// File doesn't exist or is invalid, no global buttons to load
			}
		}

		// Load workspace buttons
		if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
			const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
			const buttonsFilePath = path.join(workspaceRoot, '.vscode', 'devboost.json');

			try {
				const content = await fs.readFile(buttonsFilePath, 'utf-8');
				const workspaceButtons = JSON.parse(content);
				this.buttons.push(...workspaceButtons.map((b: Button) => ({ ...b, scope: 'workspace' as const })));
			} catch {
				// File doesn't exist, no workspace buttons to load
			}
		}

		this.refresh();
	}

	getTreeItem(element: TreeItemBase): vscode.TreeItem {
		return element;
	}

	getChildren(element?: TreeItemBase): Thenable<TreeItemBase[]> {
		// Root level: show SmartCmd parent
		if (!element) {
			const totalButtons = this.buttons.length;
			if (totalButtons === 0) {
				return Promise.resolve([]);
			}
			return Promise.resolve([new SmartCmdTreeItem(totalButtons)]);
		}

		// If element is SmartCmd, return sections (Global and Workspace)
		if (element instanceof SmartCmdTreeItem) {
			const globalButtons = this.buttons.filter(b => b.scope === 'global');
			const workspaceButtons = this.buttons.filter(b => b.scope === 'workspace');

			const sections: TreeItemBase[] = [];
			
			// Add Global section if there are global buttons
			if (globalButtons.length > 0) {
				sections.push(new SectionTreeItem('global', globalButtons.length));
			}
			
			// Add Workspace section if there are workspace buttons
			if (workspaceButtons.length > 0) {
				sections.push(new SectionTreeItem('workspace', workspaceButtons.length));
			}

			return Promise.resolve(sections);
		}

		// If element is a section, return its buttons
		if (element instanceof SectionTreeItem) {
			const sectionButtons = this.buttons
				.filter(b => b.scope === element.section)
				.map(button => new ButtonTreeItem(button, vscode.TreeItemCollapsibleState.None));
			
			return Promise.resolve(sectionButtons);
		}

		// If element is a button, it has no children
		return Promise.resolve([]);
	}

	async addButtons(buttons: Button[], scope: 'workspace' | 'global'): Promise<number> {
		if (!buttons || buttons.length === 0) {
			vscode.window.showWarningMessage('DevBoost: No buttons to add.');
			return 0;
		}

		// Validate buttons and check for duplicates
		const validButtons: Button[] = [];
		const duplicateButtons: Array<{newName: string, existingName: string, button: Button}> = [];
		const invalidButtons: number[] = [];

		for (let i = 0; i < buttons.length; i++) {
			const b = buttons[i];
			
			// Check if button is valid
			if (!b.name || !b.cmd || b.name.trim().length === 0 || b.cmd.trim().length === 0) {
				console.warn('DevBoost: Skipping invalid button:', b);
				invalidButtons.push(i);
				continue;
			}

			// Check for duplicates using AI-powered semantic comparison
			const duplicateInfo = await this.checkDuplicate(b, scope);

			if (duplicateInfo) {
				duplicateButtons.push({newName: b.name, existingName: duplicateInfo, button: b});
				console.warn('DevBoost: Duplicate/similar button:', b.name, '(similar to:', duplicateInfo + ')');
			} else {
				validButtons.push(b);
			}
		}

		// Show feedback about duplicates
		if (duplicateButtons.length > 0) {
			if (duplicateButtons.length === 1) {
				// If there's only one duplicate, ask user for confirmation
				const dup = duplicateButtons[0];
				const result = await vscode.window.showWarningMessage(
					`DevBoost: Button "${dup.newName}" appears to be similar to existing button "${dup.existingName}". Do you want to add it anyway?`,
					{ modal: true },
					'Add Anyway'
				);
				
				// If user chose to add anyway, move it to valid buttons
				if (result === 'Add Anyway') {
					validButtons.push(dup.button);
					duplicateButtons.length = 0; // Clear duplicates array since we're adding it
				} else {
					vscode.window.showInformationMessage('DevBoost: Button addition cancelled.');
				}
			} else {
				const dupMsg = `Suggested new ${duplicateButtons.length} buttons are similar to existing ones: ${duplicateButtons.slice(0, 3).map(d => `"${d.newName}"`).join(', ')}${duplicateButtons.length > 3 ? '...' : ''}`;
				vscode.window.showWarningMessage(`DevBoost: ${dupMsg}`);
			}
		}

		if (validButtons.length === 0) {
			if (invalidButtons.length === 0) {
				if(duplicateButtons.length > 1) 
					vscode.window.showInformationMessage('All buttons are similar to existing ones. No new buttons added.');
			} else {
				vscode.window.showWarningMessage('DevBoost: No valid buttons to add.');
			}
			return 0;
		}

		// Add valid, non-duplicate buttons
		const newButtons = validButtons.map(b => ({ ...b, scope }));
		this.buttons.push(...newButtons);
		await this.saveButtons(validButtons, scope);
		this.refresh();
		
		// Show summary message
		const messages: string[] = [];
		if (validButtons.length > 0) {
			messages.push(`Added ${validButtons.length} button${validButtons.length > 1 ? 's' : ''}`);
		}
		if (duplicateButtons.length > 0) {
			messages.push(`${duplicateButtons.length} similar button${duplicateButtons.length > 1 ? 's' : ''} skipped`);
		}
		if (invalidButtons.length > 0) {
			messages.push(`${invalidButtons.length} invalid button${invalidButtons.length > 1 ? 's' : ''} skipped`);
		}
		
		vscode.window.showInformationMessage(`DevBoost: ${messages.join(', ')}.`);
		return validButtons.length;
	}

	// AI-powered duplicate detection using semantic similarity
	// Returns the name of the existing button if duplicate found, null otherwise
	private async checkDuplicate(newButton: Button, targetScope: 'workspace' | 'global'): Promise<string | null> {
		return await aiServices.checkDuplicateButton(newButton, this.buttons, targetScope);
	}

	async deleteButton(item: ButtonTreeItem): Promise<void> {
		console.warn('Delete button invoked for:', item.button);
		if (!item || !item.button) {
			vscode.window.showWarningMessage('DevBoost: Invalid button item.');
			return;
		}

		const index = this.buttons.findIndex(b => b.name === item.button.name && b.cmd === item.button.cmd && b.scope === item.button.scope);
		if (index === -1) {
			vscode.window.showWarningMessage(`DevBoost: Button "${item.button.name}" not found.`);
			return;
		}

		const button = this.buttons[index];
		this.buttons.splice(index, 1);
		
		// Remove from storage
		try {
			if (button.scope === 'global') {
				await this.saveGlobalButtons();
			} else {
				await this.saveWorkspaceButtons();
			}
			
			this.refresh();
			vscode.window.showInformationMessage(`Deleted button: ${button.name}`);
		} catch (error) {
			vscode.window.showErrorMessage(`Failed to delete button: ${button.name}`);
			console.error('Delete button error:', error);
		}
	}

	async editButton(item: ButtonTreeItem): Promise<void> {
		if (!item || !item.button) {
			vscode.window.showWarningMessage('DevBoost: Invalid button item.');
			return;
		}

		const index = this.buttons.findIndex(b => b.name === item.button.name && b.cmd === item.button.cmd);
		if (index === -1) {
			vscode.window.showWarningMessage(`DevBoost: Button "${item.button.name}" not found.`);
			return;
		}

		const button = this.buttons[index];

		// Get new name
		const newName = await vscode.window.showInputBox({
			prompt: 'Edit button name',
			value: button.name,
			validateInput: (value) => {
				if (!value || value.trim().length === 0) {
					return 'Button name cannot be empty';
				}
				return null;
			}
		});

		if (!newName) {
			vscode.window.showInformationMessage('Edit cancelled.');
			return;
		}

		// Get new description
		const currentDesc = button.user_description || '';
		const newUserDescription = await vscode.window.showInputBox({
			prompt: 'Edit user description (optional)',
			value: currentDesc,
			placeHolder: 'Brief description of what this button does'
		});

		// Update button - keep user_description, preserve ai_description
		this.buttons[index] = {
			...button,
			name: newName.trim(),
			user_description: newUserDescription?.trim() || button.user_description
		};

		// Save to storage
		try {
			if (button.scope === 'global') {
				await this.saveGlobalButtons();
			} else {
				await this.saveWorkspaceButtons();
			}
			
			this.refresh();
			vscode.window.showInformationMessage(`Updated button: ${newName}`);
		} catch (error) {
			vscode.window.showErrorMessage(`Failed to update button: ${button.name}`);
			console.error('Edit button error:', error);
		}
	}

	private async saveButtons(buttons: Button[], scope: 'workspace' | 'global'): Promise<void> {
		if (scope === 'global') {
			await this.saveGlobalButtons();
		} else {
			await this.saveWorkspaceButtons();
		}
	}

	private async saveGlobalButtons(): Promise<void> {
		if (!globalButtonsPath) {
			return;
		}

		try {
			// Ensure the directory exists
			await fs.mkdir(path.dirname(globalButtonsPath), { recursive: true });
			
			const globalButtons = this.buttons
				.filter(b => b.scope === 'global')
				.map(({ scope, ...b }) => b);
			
			await fs.writeFile(globalButtonsPath, JSON.stringify(globalButtons, null, 2));
		} catch (error) {
			console.error('Error saving global buttons:', error);
		}
	}

	private async saveWorkspaceButtons(): Promise<void> {
		if (!vscode.workspace.workspaceFolders || vscode.workspace.workspaceFolders.length === 0) {
			return;
		}

		const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
		const buttonsFilePath = path.join(workspaceRoot, '.vscode', 'devboost.json');

		try {
			await fs.mkdir(path.dirname(buttonsFilePath), { recursive: true });
			const workspaceButtons = this.buttons
				.filter(b => b.scope === 'workspace')
				.map(({ scope, ...b }) => b);
			await fs.writeFile(buttonsFilePath, JSON.stringify(workspaceButtons, null, 2));
		} catch (error) {
			console.error('Error saving workspace buttons:', error);
		}
	}
}

// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed
export function activate(context: vscode.ExtensionContext) {

	console.log('DevBoost extension is now active!');

	// Initialize global extension paths (in extension's global storage)
	const globalStoragePath = context.globalStorageUri.fsPath;
	globalButtonsPath = path.join(globalStoragePath, 'global-buttons.json');
	promptInputPath = path.join(globalStoragePath, 'prompt-input.md');

	// Ensure global buttons file exists
	(async () => {
		try {
			if (globalButtonsPath) {
				await fs.mkdir(path.dirname(globalButtonsPath), { recursive: true });
				try {
					await fs.access(globalButtonsPath);
				} catch {
					// File doesn't exist, create it with empty array
					await fs.writeFile(globalButtonsPath, '[]');
					console.log('DevBoost: Initialized global buttons file');
				}
			}
		} catch (error) {
			console.error('DevBoost: Error initializing global buttons file:', error);
		}
	})();

	// Initialize activity log path
	if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
		const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
		activityLogPath = path.join(workspaceRoot, '.vscode', 'activity.log');
	}

	// Setup activity logging
	setupActivityLogging(context);

	// Create and register the tree view provider
	buttonsProvider = new ButtonsTreeProvider(context);
	const treeView = vscode.window.createTreeView('devboost.buttonsView', {
		treeDataProvider: buttonsProvider,
		showCollapseAll: false
	});
	context.subscriptions.push(treeView);

	// Load existing buttons
	buttonsProvider.loadButtons();

	// Register commands
	const helloWorldDisposable = vscode.commands.registerCommand('DevBoost.helloWorld', () => {
		vscode.window.showInformationMessage('Hello World from DevBoost!');
	});

	const createButtonsDisposable = vscode.commands.registerCommand('devboost.smartCmdCreateButtons', async () => {
		await createAIButtons(context);
	});

	const createCustomButtonDisposable = vscode.commands.registerCommand('devboost.smartCmdCreateCustomButton', async (sectionObj: SectionTreeItem | any) => {

		if(sectionObj && typeof sectionObj === 'object' && 'section' in sectionObj) {
			if(sectionObj.section == 'global') 
				await createCustomButton(context, 'Global');
			else 
				await createCustomButton(context, 'Workspace');
		}
		else {
			await createCustomButton(context);
		}
	});

	const executeButtonDisposable = vscode.commands.registerCommand('devboost.executeButton', async (buttonOrCmd: Button | string | any) => {
		// Handle different argument types
		let button: Button;
		
		if (typeof buttonOrCmd === 'string') {
			// Legacy: just a command string
			button = { name: 'Command', cmd: buttonOrCmd };
		} else if (buttonOrCmd && typeof buttonOrCmd === 'object' && 'cmd' in buttonOrCmd && 'name' in buttonOrCmd) {
			// New: Button object
			button = buttonOrCmd as Button;
		} else if (buttonOrCmd && typeof buttonOrCmd === 'object' && 'button' in buttonOrCmd) {
			// TreeItem wrapper
			button = buttonOrCmd.button;
		} else {
			vscode.window.showWarningMessage('DevBoost: No command provided to execute.');
			return;
		}
		
		await executeButtonCommand(button);
	});

	const deleteButtonDisposable = vscode.commands.registerCommand('devboost.deleteButton', async (item: ButtonTreeItem) => {
		if (!item) {
			vscode.window.showWarningMessage('DevBoost: No button selected to delete.');
			return;
		}
		await buttonsProvider.deleteButton(item);
	});

	const editButtonDisposable = vscode.commands.registerCommand('devboost.editButton', async (item: ButtonTreeItem) => {
		if (!item) {
			vscode.window.showWarningMessage('DevBoost: No button selected to edit.');
			return;
		}
		await buttonsProvider.editButton(item);
	});

	const addToGlobalDisposable = vscode.commands.registerCommand('devboost.addToGlobal', async (item: ButtonTreeItem) => {
		if (!item) {
			vscode.window.showWarningMessage('DevBoost: No button selected to add to global.');
			return;
		}

		// Check if button is already global
		if (item.button.scope === 'global') {
			vscode.window.showInformationMessage('DevBoost: This button is already in global scope.');
			return;
		}

		// Use AI to validate if button is suitable for global scope
		vscode.window.showInformationMessage('Analyzing button compatibility with global scope...');
		const isGlobalSafe = await aiServices.checkIfButtonIsGlobalSafe(item.button);

		if (!isGlobalSafe) {
			const result = await vscode.window.showWarningMessage(
				`DevBoost: This button appears to be workspace-specific (e.g., contains project paths, workspace settings, or project-specific commands). ` +
				`Adding it to global scope might cause issues in other projects. Do you want to continue anyway?`,
				{ modal: true },  // Make it modal so it doesn't auto-dismiss
				'Continue Anyway'
			);

			// If user didn't click "Continue Anyway" (clicked Cancel or dismissed), abort
			if (result !== 'Continue Anyway') {
				vscode.window.showInformationMessage('DevBoost: Add to global cancelled.');
				return;
			}
		}

		// Create a copy of the button for global scope
		const globalButton: Button = {
			name: item.button.name,
			cmd: item.button.cmd,
			user_description: item.button.user_description,
			ai_description: item.button.ai_description,
			scope: 'global'
		};

		// Use addButtons which handles duplicate detection automatically
		const addedCount = await buttonsProvider.addButtons([globalButton], 'global');
		
		if (addedCount > 0) {
			vscode.window.showInformationMessage(`DevBoost: Button "${item.button.name}" added to global buttons.`);
		}
		// If addedCount is 0, addButtons already showed appropriate warning message
	});

	const refreshButtonsDisposable = vscode.commands.registerCommand('devboost.refreshButtons', async () => {
		await buttonsProvider.loadButtons();
		vscode.window.showInformationMessage('Buttons refreshed!');
	});

	const openButtonsFileDisposable = vscode.commands.registerCommand('devboost.openButtonsFile', async (item: SectionTreeItem) => {
		if (!item || !(item instanceof SectionTreeItem)) {
			vscode.window.showWarningMessage('DevBoost: Invalid section item.');
			return;
		}

		try {
			let filePath: string;
			
			if (item.section === 'global') {
				// Open global buttons file
				if (!globalButtonsPath) {
					vscode.window.showErrorMessage('Global buttons file path not initialized.');
					return;
				}
				filePath = globalButtonsPath;
				
				// Ensure the file exists
				try {
					await fs.access(filePath);
				} catch {
					// Create the file if it doesn't exist
					await fs.mkdir(path.dirname(filePath), { recursive: true });
					await fs.writeFile(filePath, '[]');
				}
			} else {
				// Open workspace buttons file
				if (!vscode.workspace.workspaceFolders || vscode.workspace.workspaceFolders.length === 0) {
					vscode.window.showErrorMessage('No workspace folder open.');
					return;
				}
				
				const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
				filePath = path.join(workspaceRoot, '.vscode', 'devboost.json');
				
				// Ensure the file exists
				try {
					await fs.access(filePath);
				} catch {
					// Create the file if it doesn't exist
					await fs.mkdir(path.dirname(filePath), { recursive: true });
					await fs.writeFile(filePath, '[]');
				}
			}
			
			// Open the file in editor
			const document = await vscode.workspace.openTextDocument(filePath);
			await vscode.window.showTextDocument(document, { preview: false });
		} catch (error) {
			console.error('Error opening buttons file:', error);
			vscode.window.showErrorMessage('Failed to open buttons file.');
		}
	});

	context.subscriptions.push(
		helloWorldDisposable, 
		createButtonsDisposable, 
		createCustomButtonDisposable,
		executeButtonDisposable,
		deleteButtonDisposable,
		editButtonDisposable,
		addToGlobalDisposable,
		refreshButtonsDisposable,
		openButtonsFileDisposable
	);

	// Listen for workspace folder changes to reload buttons
	context.subscriptions.push(
		vscode.workspace.onDidChangeWorkspaceFolders(async (event) => {
			console.log('DevBoost: Workspace folders changed');
			
			// Update activity log path for new workspace
			if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
				const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
				activityLogPath = path.join(workspaceRoot, '.vscode', 'activity.log');
				console.log('DevBoost: Updated activity log path:', activityLogPath);
			} else {
				activityLogPath = undefined;
			}
			
			// Reload buttons to get new workspace buttons
			await buttonsProvider.loadButtons();
			vscode.window.showInformationMessage('DevBoost: Buttons reloaded for new workspace');
		})
	);
}

// Setup activity logging system
function setupActivityLogging(context: vscode.ExtensionContext) {
	// Note: VS Code doesn't have onDidExecuteCommand for all commands
	// We'll log specific commands we care about through our own tracking
	
	// Log file create operations
	context.subscriptions.push(
		vscode.workspace.onDidCreateFiles(async (event) => {
			for (const file of event.files) {
				await logActivity('Create', file.fsPath);
			}
		})
	);

	// Log file delete operations
	context.subscriptions.push(
		vscode.workspace.onDidDeleteFiles(async (event) => {
			for (const file of event.files) {
				await logActivity('Delete', file.fsPath);
			}
		})
	);

	// Log file rename operations
	context.subscriptions.push(
		vscode.workspace.onDidRenameFiles(async (event) => {
			for (const rename of event.files) {
				await logActivity('Rename', `${rename.oldUri.fsPath} to ${rename.newUri.fsPath}`);
			}
		})
	);

	// Log when terminal commands are executed
	context.subscriptions.push(
		vscode.window.onDidEndTerminalShellExecution(async (event) => {
			const commandLine = event.execution.commandLine.value;
			const command = commandLine.trim();
			const exitCode = event.exitCode;
			
			// Get current workspace path for tracking
			const workspacePath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
			
			// Skip commands executed by SmartCmd buttons in this workspace
			if (workspacePath) {
				const workspaceCommands = smartCmdExecutedCommands.get(workspacePath);
				if (workspaceCommands?.has(command)) {
					console.log(`DevBoost: Skipping SmartCmd-executed command in workspace: ${command}`);
					workspaceCommands.delete(command); // Clean up after tracking
					
					// Clean up empty sets to prevent memory leaks
					if (workspaceCommands.size === 0) {
						smartCmdExecutedCommands.delete(workspacePath);
					}
					return;
				}
			}
			
			// Log successful commands (exit code 0) and interrupted commands (exit code 130, SIGINT)
			// Skip commands with exit code 127 (command not found) and 126 (command not executable)
			if (exitCode === 0 || exitCode === 130 || exitCode === undefined) {
				await logActivity('Command', command);
			} else if (exitCode === 127 || exitCode === 126) {
				console.log(`DevBoost: Skipping invalid command (exit code ${exitCode}): ${command}`);
			} else {
				// Log other non-zero exit codes but still save them as they might be valid commands that failed for other reasons
				await logActivity('Command', command);
			}
		})
	);
}

// Log activity to .vscode/activity.log
async function logActivity(type: string, detail: string) {
	// Validate parameters
	if (!type || !detail || type.trim().length === 0 || detail.trim().length === 0) {
		console.log('DevBoost: Skipping log entry - invalid type or detail');
		return;
	}

	if (!activityLogPath) {
		console.log('DevBoost: Activity log path not initialized');
		return;
	}

	try {
		const timestamp = new Date().toISOString();
		const logEntry = `${timestamp} | ${type.trim()}: ${detail.trim()}\n`;
		
		// Create .vscode directory if it doesn't exist
		const vscodeDirPath = path.dirname(activityLogPath);
		await fs.mkdir(vscodeDirPath, { recursive: true });
		
		// Append to activity log
		await fs.appendFile(activityLogPath, logEntry);
	} catch (error) {
		console.error('DevBoost: Error logging activity:', error);
	}
}

// Create AI-suggested buttons based on activity log
async function createAIButtons(context: vscode.ExtensionContext) {
	// Check if workspace is open
	if (!vscode.workspace.workspaceFolders || vscode.workspace.workspaceFolders.length === 0) {
		vscode.window.showErrorMessage('Please open a workspace to use SmartCmd.');
		return;
	}

	if (!activityLogPath) {
		vscode.window.showErrorMessage('Activity log path not initialized.');
		return;
	}

	try {
		// Check if activity log file exists
		try {
			await fs.access(activityLogPath);
		} catch (error) {
			// File doesn't exist
			vscode.window.showInformationMessage(
				'No activity log found yet. DevBoost tracks your terminal commands and file operations. ' +
				'Work in your project for a while, then try again. Or create a custom button instead.',
				'Create Custom Button'
			).then(selection => {
				if (selection === 'Create Custom Button') {
					vscode.commands.executeCommand('devboost.smartCmdCreateCustomButton');
				}
			});
			return;
		}

		// Read activity log
		const logContent = await fs.readFile(activityLogPath, 'utf-8');
		
		if (!logContent || logContent.trim().length === 0) {
			vscode.window.showInformationMessage(
				'Activity log is empty. Work in your project for a while to build up command history, then try again.',
				'Create Custom Button'
			).then(selection => {
				if (selection === 'Create Custom Button') {
					vscode.commands.executeCommand('devboost.smartCmdCreateCustomButton');
				}
			});
			return;
		}

		// Parse and analyze activities
		const activities = parseActivityLog(logContent);
		console.log('DevBoost: Parsed activities:', activities);
		const topActivities = getTopActivities(activities, 5);
		console.log('DevBoost: Top activities:', topActivities);

		if (topActivities.length < 3) {
			vscode.window.showInformationMessage(
				'Not enough activity data found. Continue working in your project to build command history.',
				'Create Custom Button'
			).then(selection => {
				if (selection === 'Create Custom Button') {
					vscode.commands.executeCommand('devboost.smartCmdCreateCustomButton');
				}
			});
			return;
		}

		// Get AI suggestions from GitHub Copilot
		vscode.window.showInformationMessage('Analyzing your workflow patterns...');
		const osInfo = getSystemInfo();
		const buttons = await aiServices.getAISuggestions(topActivities, osInfo.platform, osInfo.shell);

		if (buttons.length === 0) {
			vscode.window.showWarningMessage('Could not generate button suggestions. Please try again.');
			return;
		}

		// Add buttons to tree view
		const addedCount = await buttonsProvider.addButtons(buttons, 'workspace');

		if (addedCount > 0) {
			vscode.window.showInformationMessage(`âœ¨ Created ${addedCount} AI-suggested button${addedCount > 1 ? 's' : ''}!`);
		}
	} catch (error: any) {
		console.error('DevBoost: Error creating AI buttons:', error);
		
		// Provide specific error messages
		if (error.code === 'ENOENT') {
			vscode.window.showInformationMessage(
				'Activity log not found. Start working in your project, and DevBoost will track your commands automatically.',
				'Create Custom Button'
			).then(selection => {
				if (selection === 'Create Custom Button') {
					vscode.commands.executeCommand('devboost.smartCmdCreateCustomButton');
				}
			});
		} else {
			vscode.window.showErrorMessage(`Failed to create AI buttons: ${error.message || 'Unknown error'}`);
		}
	}
}

// Create custom button from user description
async function createCustomButton(context: vscode.ExtensionContext, scopeInput?: 'Workspace' | 'Global') {

	// Get scope
	const scope = scopeInput || await vscode.window.showQuickPick(['Workspace', 'Global'], {
		placeHolder: 'Where should this button be available?'
	});

	if (!scope || scope.trim().length === 0 || (scope !== 'Workspace' && scope !== 'Global')) {
		vscode.window.showInformationMessage('Invalid scope selected. Please choose either "Workspace" or "Global".');
		return;
	}

	if (!promptInputPath) {
		vscode.window.showErrorMessage('Prompt input file path not initialized.');
		return;
	}

	try {
		// Ensure the directory exists
		await fs.mkdir(path.dirname(promptInputPath), { recursive: true });

		// Clean the prompt input file (keep it empty)
		await fs.writeFile(promptInputPath, '');

		// Open the dedicated prompt input file
		const doc = await vscode.workspace.openTextDocument(promptInputPath);
		await vscode.window.showTextDocument(doc, { preview: false });

		// Show info message with tips
		vscode.window.showInformationMessage(
			'ðŸ’¡ Describe the functionality of the button you want to create, then close this file to move on. Example: "Button to add changes and commit code using git"',
			{ modal: true }
		);

		// Wait for the file to be closed - use multiple events to detect closure
		const description = await new Promise<string>((resolve) => {
			let resolved = false;
			
			const checkAndResolve = async () => {
				if (resolved) return;
				
				// Check if document is still open in tabs
				const isOpen = vscode.window.tabGroups.all
					.flatMap(group => group.tabs)
					.some(tab => {
						const tabInput = tab.input as any;
						return tabInput?.uri?.fsPath === doc.uri.fsPath;
					});
				
				if (!isOpen) {
					console.log('Prompt input file closed, reading content...');
					resolved = true;
					disposable1.dispose();
					disposable2.dispose();
					
					// Read content from the document
					const content = doc.getText().trim();
					
					// Clean the file after reading
					fs.writeFile(promptInputPath!, '').catch(error => {
						console.error('Error cleaning prompt file:', error);
					});
					
					console.log('File closed, content read:', content);
					resolve(content);
				}
			};
			
			// Listen to tab changes
			const disposable1 = vscode.window.tabGroups.onDidChangeTabs(async () => {
				console.log('Tab changed, checking if prompt file is closed...');
				await checkAndResolve();
			});
			
			// Also listen to visible editors change as backup
			const disposable2 = vscode.window.onDidChangeVisibleTextEditors(async () => {
				console.log('Visible editors changed, checking if prompt file is closed...');
				await checkAndResolve();
			});
		});

		console.warn('User button description:', description);

		// If content is empty, return
		if (!description || description.length === 0) {
			return;
		}


		// Get user input whether use AI or manual
		const useAI = await vscode.window.showQuickPick(['Yes', 'No'], {
			placeHolder: 'Use AI to generate the button?'
		});

		if (!useAI) {
			return;
		}

		if (useAI === 'No') {
			const button = await getManualButtonInput(description);

			if (!button) {
				vscode.window.showWarningMessage('Could not generate button. Please try again.');
				return;
			}

			// Add button to tree view
			const scopeType = scope === 'Global' ? 'global' : 'workspace';
			const addedCount = await buttonsProvider.addButtons([button], scopeType);

			if (addedCount > 0) {
				vscode.window.showInformationMessage(`âœ… Created custom button: ${button.name}`);
			}
			return;
		}

		await vscode.window.withProgress({
			location: vscode.ProgressLocation.Notification,
			title: "Creating custom button...",
			cancellable: false
		}, async (progress) => {
			// Get AI suggestion from GitHub Copilot
			const osInfo = getSystemInfo();
			const button = await aiServices.getCustomButtonSuggestion(description, osInfo.platform, osInfo.shell);

			if (!button) {
				vscode.window.showWarningMessage('Could not generate button. Please try again.');
				return;
			}

			// Add button to tree view
			const scopeType = scope === 'Global' ? 'global' : 'workspace';
			const addedCount = await buttonsProvider.addButtons([button], scopeType);

			if (addedCount > 0) {
				vscode.window.showInformationMessage(`âœ… Created custom button: ${button.name}`);
			}
		});

	} catch (error) {
		console.error('Error creating custom button:', error);
		vscode.window.showErrorMessage('Failed to create custom button.');
	}
}

// Parse activity log and count frequencies
function parseActivityLog(logContent: string): Map<string, number> {
	const activities = new Map<string, number>();
	const lines = logContent.split('\n').filter(line => line.trim().length > 0);

	for (const line of lines) {
		// Match format: 2025-10-27T10:37:41.083Z | Type: detail
		const match = line.match(/\d{4}-\d{2}-\d{2}T[\d:.]+Z\s*\|\s*(.+?)\s*:\s*(.+)$/);
		if (match) {
			const type = match[1].trim();
			const detail = match[2].trim();
			const activity = `${type}: ${detail}`;
			activities.set(activity, (activities.get(activity) || 0) + 1);
		}
	}
	return activities;
}

// Get top N activities by frequency
function getTopActivities(activities: Map<string, number>, count: number): string[] {
	return Array.from(activities.entries())
		.sort((a, b) => b[1] - a[1])
		.slice(0, count)
		.map(([activity]) => activity);
}

// Execute button command with input field support
async function executeButtonCommand(button: Button) {
	if (!button || !button.cmd || button.cmd.trim().length === 0) {
		vscode.window.showWarningMessage('No command specified. Please provide a valid command to execute.');
		return;
	}

	let finalCommand = button.cmd.trim();

	// Handle input fields if present
	if (button.inputs && button.inputs.length > 0) {
		for (const input of button.inputs) {
			const userInput = await vscode.window.showInputBox({
				prompt: input.placeholder,
				placeHolder: input.placeholder,
				validateInput: (value) => {
					if (!value || value.trim().length === 0) {
						return 'Input cannot be empty';
					}
					return null;
				}
			});

			if (!userInput) {
				vscode.window.showInformationMessage('Command execution cancelled.');
				return;
			}

			// Replace variable placeholder with user input
			finalCommand = finalCommand.replace(new RegExp(input.variable.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), userInput.trim());
		}
	}

	// Check if it's a single-word VS Code command
	if (!finalCommand.includes(' ') && !finalCommand.includes('&&') && !finalCommand.includes('||') && !finalCommand.includes(';')) {
		try {
			await vscode.commands.executeCommand(finalCommand);
			vscode.window.showInformationMessage(`Executed VS Code command: ${finalCommand}`);
			return;
		} catch (error) {
			// Not a VS Code command, fall through to terminal execution
			console.log(`Not a VS Code command, executing in terminal: ${finalCommand}`);
		}
	}

	// Execute as terminal command
	try {
		const terminal = vscode.window.activeTerminal || vscode.window.createTerminal('DevBoost');
		terminal.show();
		
		// Track this command as SmartCmd-executed to exclude from activity log (workspace-specific)
		const workspacePath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
		if (workspacePath) {
			if (!smartCmdExecutedCommands.has(workspacePath)) {
				smartCmdExecutedCommands.set(workspacePath, new Set());
			}
			smartCmdExecutedCommands.get(workspacePath)!.add(finalCommand);
		}
		
		terminal.sendText(finalCommand);
		vscode.window.setStatusBarMessage(`âš¡ Executed: ${button.name}`, 3000);
	} catch (error) {
		vscode.window.showErrorMessage(`Failed to execute command: ${button.name}`);
		console.error('Command execution error:', error);
	}
}

// Get system information for AI context
function getSystemInfo(): { platform: string; shell: string} {
	// Determine OS
	let platform = 'Unknown';
	if (process.platform === 'win32') {
		platform = 'Windows';
	} else if (process.platform === 'darwin') {
		platform = 'macOS';
	} else if (process.platform === 'linux') {
		platform = 'Linux';
	}

	// Get shell information
	const shell = process.env.SHELL || process.env.COMSPEC || 'Unknown shell';
	const shellName = path.basename(shell).replace(/\.(exe|com|bat)$/i, '');

	return {
		platform,
		shell: shellName
	};
}

// Manual button input as fallback
async function getManualButtonInput(description: string): Promise<Button | null> {
	const name = await vscode.window.showInputBox({
		prompt: 'Enter button name',
		value: description.substring(0, 15),
		validateInput: (value) => {
			if (!value || value.trim().length === 0) {
				return 'Button name cannot be empty';
			}
			if (value.length > 50) {
				return 'Button name is too long (max 50 characters)';
			}
			return null;
		}
	});

	if (!name) {
		vscode.window.showInformationMessage('Button creation cancelled.');
		return null;
	}

	const cmd = await vscode.window.showInputBox({
		prompt: 'Enter command to execute (use {variableName} for inputs)',
		placeHolder: 'e.g., git commit -m \'{message}\' or npm test',
		validateInput: (value) => {
			if (!value || value.trim().length === 0) {
				return 'Command cannot be empty';
			}
			return null;
		}
	});

	if (!cmd) {
		vscode.window.showInformationMessage('Button creation cancelled.');
		return null;
	}

	// Check if command has input placeholders
	const inputMatches = cmd.match(/\{(\w+)\}/g);
	const inputs: InputField[] = [];

	if (inputMatches && inputMatches.length > 0) {
		for (const match of inputMatches) {
			const variable = match;
			const varName = match.slice(1, -1); // Remove { and }
			
			const placeholder = await vscode.window.showInputBox({
				prompt: `Enter placeholder text for ${variable}`,
				placeHolder: `e.g., Enter ${varName}`
			});

			if (placeholder) {
				inputs.push({
					placeholder: placeholder.trim(),
					variable: variable
				});
			}
		}
	}

	return {
		name: name.trim(),
		cmd: cmd.trim(),
		user_description: description?.trim(), // Store as user_description
		inputs: inputs.length > 0 ? inputs : undefined
	};
}

// This method is called when your extension is deactivated
export function deactivate() {
	// Cleanup handled by context.subscriptions
}
